import Channel from "../models/channel.models.js";
import User from "../models/user.models.js";
import  profileUploadToCloudinary  from "../middleware/profileCloudinary.middleware.js";

export const createChannel = async (req, res) => {
  // Debugging: Log incoming request
  console.log("Request received - User:", req.user?._id);
  console.log("Request body:", req.body);
  console.log("Uploaded file:", req.file ? req.file.originalname : "None");

  // Validation
  if (!req.user) {
    console.log("Error: No authenticated user");
    return res.status(401).json({ message: "Authentication required" });
  }

  if (!req.body.channel_name) {
    console.log("Error: Missing channel_name");
    return res.status(400).json({ message: "Channel name is required." });
  }

  if (!req.file) {
    console.log("Error: No file uploaded");
    return res.status(400).json({ message: "Channel avatar is required." });
  }

  try {
    // Upload to Cloudinary with debugging
    console.log("Starting Cloudinary upload...");
    const result = await profileUploadToCloudinary(req.file);
    console.log("Cloudinary upload success:", {
      url: result.secure_url,
      size: result.bytes
    });

    // Create channel
    const channelData = {
      user: req.user._id,
      channel_name: req.body.channel_name,
      avatar: result.secure_url,
    };

    const channel = await Channel.create(channelData);
    console.log("Channel created in DB:", channel._id);

    // Update user
    await User.findByIdAndUpdate(req.user._id, { isChannel: true });
    console.log("User updated with channel status");

    return res.status(201).json({
      success: true,
      message: "Channel created successfully",
      channel
    });

  } catch (error) {
    console.error("Full error stack:", error);
    
    if (error.code === 11000) {
      return res.status(409).json({
        success: false,
        message: "User already has a channel"
      });
    }

    return res.status(500).json({
      success: false,
      message: "Server error",
      error: error.message
    });
  }
};


import multer from "multer";


const storage = multer.memoryStorage();
const fileFilter = (req, file, cb) => {
  const validTypes = /jpeg|jpg|png/i;

  const extValid = validTypes.test(file.originalname);

  const mimeValid = validTypes.test(file.mimetype);


  if(mimeValid && extValid) { 
    cb(null, true);
  }else {
    cb(new Error('Only JPEG, JPG, PNG images are allowed.'));
  }


}
const upload = multer({
  storage,
  limits: {fileSize: 5 * 1024 * 1024},
  fileFilter
})




export const profileUploadMiddleware = upload.single('avatar');

export default upload;


// import { v2 as cloudinary } from "cloudinary";
// import streamifier from "streamifier";
// import dotenv from "dotenv";
// dotenv.config();

// function profileUploadToCloudinary(file) {
//   return new Promise((resolve, reject) => {
//  if (!file || !file.buffer) {
//       return reject(new Error("Invalid file object or missing buffer"));
//     }

//     const profileCloudinary = cloudinary;
//     profileCloudinary.config({
//       cloud_name: process.env.PROFILE_CLOUD_NAME,
//       api_key: process.env.PROFILE_API_KEY,
//       api_secret: process.env.PROFILE_API_SECRET,
//     });
//     const uploadStream = cloudinary.uploader.upload_stream(
//       {
//         folder: "profile-img",
//         transformation: [
//           { width: 500, height: 500, crop: "limit" },
//           {
//             quality: "auto",
//           },
//         ],
//       },

//       (error, result) => {
//         if (error) reject(error);
//         else resolve(result);
//       }
//     );
//     streamifier.createReadStream(file.buffer).pipe(uploadStream);
//   });
// }

// export default profileUploadToCloudinary;
//========================================
import { v2 as cloudinary } from "cloudinary";
import streamifier from "streamifier";
import dotenv from "dotenv";
dotenv.config();

// =============================================
// MAJOR UPDATES:
// 1. Cloudinary config moved OUTSIDE the function 
//    (no need to reconfigure on every upload)
// 2. Added detailed error logging
// 3. Added file validation
// 4. Improved stream error handling
// 5. Explicit folder naming for channels
// =============================================

// Configure Cloudinary once when the module loads
cloudinary.config({
  cloud_name: process.env.PROFILE_CLOUD_NAME,
  api_key: process.env.PROFILE_API_KEY,
  api_secret: process.env.PROFILE_API_SECRET,
});

function profileUploadToCloudinary(file) {
  return new Promise((resolve, reject) => {
    // =========================================
    // NEW: File validation
    // =========================================
    if (!file?.buffer) {
      console.error("Upload error: Invalid file buffer");
      return reject(new Error("Invalid file data"));
    }

    console.log(`Uploading file: ${file.originalname} (${file.size} bytes)`);

    const uploadStream = cloudinary.uploader.upload_stream(
      {
        // =====================================
        // CHANGED: Folder name to 'channel-avatars'
        // (was 'profile-img')
        // =====================================
        folder: "channel-avatars",
        transformation: [
          { width: 500, height: 500, crop: "limit" },
          { quality: "auto" },
        ],
      },
      (error, result) => {
        // =====================================
        // IMPROVED: Error handling with logging
        // =====================================
        if (error) {
          console.error("Cloudinary upload failed:", error);
          reject(new Error("Failed to upload image"));
        } else {
          console.log("Upload successful:", result.secure_url);
          resolve(result);
        }
      }
    );

    // =========================================
    // NEW: Stream error handling
    // (previously unhandled errors could crash the app)
    // =========================================
    const readStream = streamifier.createReadStream(file.buffer);
    readStream.on('error', (err) => {
      console.error("Stream error:", err);
      reject(err);
    });

    readStream.pipe(uploadStream);
  });
}

export default profileUploadToCloudinary;

import express from "express";
import { createChannel } from "../controllers/channel.controllers.js";
import { profileUploadMiddleware } from "../middleware/multer.middleware.js";
import verifyToken from "../utils/verification.utils.js";

const channelRoutes = express.Router();

channelRoutes.post("/create-channel", verifyToken ,profileUploadMiddleware, createChannel)

export default channelRoutes;

import jwt from "jsonwebtoken";
import dotenv from 'dotenv';

dotenv.config();


const verifyToken = (req, res, next) => {
    const token = req.header('Authorization')?.replace('Bearer ', '') ;
    if (!token) return res.status(401).json({ error: 'No token provided.' });

    try {
        const decoded = jwt.verify(token, process.env.ACCESS_SECRET_TOKEN);
        req.user = decoded;
        // console.log(decoded);
        
        next();
    } catch (error) {
        res.status(400).json({ error: 'Invalid token.' });
    }
}

export default verifyToken;

//=============================================================================================================================

// import jwt from "jsonwebtoken";
// import dotenv from 'dotenv';
// import User from "../models/user.model.js"; // Optional: if you want full user details

// dotenv.config();

// const verifyToken = async (req, res, next) => {
//   try {
//     // Read the token from the Authorization header
//     const token = req.headers.authorization?.replace('Bearer ', '');

//     if (!token) {
//       return res.status(401).json({ message: 'Authentication required' });
//     }

//     // Verify the token
//     const decoded = jwt.verify(token, process.env.ACCESS_SECRET_TOKEN);

//     // Attach only decoded token info to req.user
//     req.user = decoded;

//     // Optionally, fetch the full user from DB if needed
//     // const user = await User.findById(decoded._id).select("-password");
//     // if (!user) return res.status(404).json({ message: "User not found" });
//     // req.user = user;

//     next();
//   } catch (error) {
//     console.error("Token verification failed:", error);
//     res.status(401).json({ message: 'Invalid or expired token' });
//   }
// };

// export default verifyToken;

import express from "express";
import dotenv from "dotenv";
import cors from "cors";
import connectDb from "./db/connectDB.js";
import userRouter from "./routes/authUser.routes.js";
import videoRoutes from "./routes/video.routes.js";
import commentRoutes from "./routes/comments.routes.js";
import channelRoutes from "./routes/channel.routes.js";

// Load environment variables
dotenv.config();

const app = express();
const port = process.env.PORT || 8080; // Added default port

// Configure CORS for your frontend
const corsOptions = {
  origin: process.env.FRONTEND_URL || "http://localhost:5173",
  credentials: true, // Allow cookies to be sent
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"]
};

// Middleware setup
app.use(cors(corsOptions)); // Enable CORS with options
app.use(express.json()); // Parse JSON bodies
app.use(express.urlencoded()); //for formdata

// Database connection
connectDb();

// Basic route
app.get("/", (req, res) => {
  res.send("Welcome to the API");
});

// Routes
app.use("/api/auth", userRouter); // Authentication routes
app.use("/api/videos", videoRoutes); // Video routes
app.use("/api/comments", commentRoutes); // Comment routes
app.use("/api",channelRoutes) //channel routes

// Error handling middleware (basic example)
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ message: "Something went wrong!" });
});

// Start server
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
  console.log(`Allowed origin: ${corsOptions.origin}`);
});